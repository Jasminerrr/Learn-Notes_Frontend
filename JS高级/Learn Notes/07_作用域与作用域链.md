## 1. 作用域
1. 理解：就是一块‘地盘’，一个代码所在的区域；
2. 是静态的（相对于上下文对象），在编写代码时就确定了，不会变；
3. 产生的作用域为 n + 1 原则，n为定义的函数，1 为全局作用域；
4. 作用：隔离变量，不同作用域下的同名变量不会有冲突（减少命名冲突）；
5. 分类：
   1. 全局作用域：指整个script标签 或者是一个单独的js文件；
   2. 函数作用域：在函数内部，这个代码的名字只在函数的内部起效果和作用；
   3. 没有块级作用域（es6有了）；
## 2. 作用域与执行上下文
1. 区别1：
   1. 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是函数调用时；
   2. 全局执行上下文是在全局作用域确定之后，js代码马上执行之前创建；
   3. 函数执行上下文是在调用函数时，函数体代码执行之前创建；
2. 区别2：
   1. 作用域时静态的，只要函数定义好了就一直存在，且不会再变化；
   2. 执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放；
3. 联系：
   1. 执行上下文是属于所在的作用域；
   2. 全局上下文--对应全局作用域；
   3. 函数上下文--对应函数作用域；
## 3. 作用域链
1. 多个上下级关系的作用域形成的链，方向是从下往上（就近原则）；
2. 作用：查找变量，沿着作用域链来查找，找到返回，找不到就报错；
3. 例如a.b：找a变量是作用域链，找到后找b(是对象的属性)，在a对象的原型链上找，找不到返回undefined；
4. 找 window.a 找不到返回undefined，找 a 找不到是报错； 
5. 面试题：
   1. 题1：
   ```
   var a = 10;
      function fn() {
          console.log(x);// 10
      }
      function show(f) {
          var x = 20;
          f();// 相当于 fn(),fn()里面没有x，在全局里面找
      }
      show(fn);
   ```
   1. 题2：
   ```
   var fn = function () {
      console.log(fn);// 输出fn函数（在全局作用域扎到fn）
   }
   fn();
   var obj = {
      fn2: function () {
         console.log(fn2);// 报错(fn2在作用域链找不到)，fn2是obj的属性，要输出this.fn2才能找到
      }
   }
   obj.fn2();
   ```
