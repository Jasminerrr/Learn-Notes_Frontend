## 1. 闭包
1. 产生闭包的条件：
   1. 函数嵌套：
   2. 内部函数引用了外部函数的数据（变量/函数）；
2. 闭包是什么：能够读取其他函数内部变量（函数）的函数；（是一个函数，(一个作用域可以访问到另外一个函数的局部变量，这个变量所在的函数就是一个闭包函数)）
   1. 使用chrome调试查看；
   2. 理解1：闭包是嵌套的内部函数（绝大多数人）；
   3. 理解2：闭包是包含被引用变量（函数）的对象（极少数人）；(保存在内部函数中的一个对象)
   4. 注意：闭包存在于嵌套的内部函数中；
```
    function fn1() {
        var a = 2;
        var b = 'abc';
        function fn2() {// 调用外部函数和内部函数就会产生新闭包
            console.log(a);
        }
        // fn2();
    }
    fn1();
```
## 2. 常见的闭包
1. 将函数作为另一个函数的返回值：
   ```
   function fn1() {
        var a = 2;
        function fn2() {
            a++;
            console.log(a);
        }
        return fn2;
    }
    var f = fn1();
    f();// 3
    f();// 4
   ```
2. 将函数作为实参传递给另一个函数调用：
   ```
   function showDelay(msg, time) {
        setTimeout(function () {
            alert(msg);
        }, time)
    }
    showDelay('hhhh', 2000);// 被引用变量是msg
   ```
## 3. 闭包的主要作用：延伸了变量的作用范围；（外面作用域可以访问内部的局部变量）
1. 使用函数内部的变量在函数操作执行完后，仍然存活在内存中（延长了局部变量的生命周期）；
2. 让函数外部可以间接操作（读写）到函数内部的数据（变量/函数）；
3. 外部函数调用了几次，就产生多少个闭包；
4. 问题：
   1. 函数执行完后，函数内部声明的局部变量是否还存在？ 一般不存在，存在于闭包中的变量才可能存在（前提是闭包所在的函数不是垃圾对象）；
   2. 在函数外部能直接访问函数内部的局部变量吗？ 不能，但可以通过闭包让外部操作它；
```
    function fn() {
        var num = 10;
        // function fun(){
        //     console.log(num);
        // }
        return function () {// 利用retrun把函数返回给fn
            console.log(num);
        }
    }
    var f = fn();
    f();// 外面作用域可以访问num，等全部调用完函数才会被销毁
    // 类似于:
    // var f = function (){
            // console.log(num);
        // }
```
## 4. 闭包的生命周期
1. 产生：在嵌套内部函数定义执行完时就产生了；
2. 死亡：在嵌套的内部函数称为垃圾对象时死亡；
   ```
   function fn1() {
    // 此时闭包已经产生（函数提升，内部函数对象已经创建）
        var a = 2;
        function fn2() {
            a++;
            console.log(a);
        }
        return fn2;
    }
    var f = fn1();
    f();// 3
    f();// 4
    f = null; // 闭包死亡（包含闭包的函数对象称为垃圾对象）
   ```
## 5. 闭包的应用：自定义JS模块(案例05)
1. 具有特定功能的js文件；
2. 将所有的数据和功能都封装在一个函数内部（私有的）；
3. 只向外暴露一个包含n个方法的对象或函数（想暴露两个函数就封装成对象）；
4. 模块的使用者，先引入JS文件，再通过模块暴露的对象调用方法来实现对应的功能；
## 5. 闭包的缺点及解决
1. 缺点：
   1. 函数执行完后，函数内的局部函数变量没有释放，占用内存时间会变长；
   2. 容易造成内存泄漏；
2. 解决：
   1. 能不用闭包就不用；
   2. 及时释放；
## 6. 内存溢出与内存泄漏
1. 内存溢出：
   1. 一种程序运行出现的错误；
   2. 当程序运行需要的内存超过了剩余的内存时，就抛出内存溢出的错误；
   ```
   // 不断创建数组，一下子就能分配很大内存
   var obj = {};
   for (var i = 0; i < 1000; i++){
       obj[i] = new Array(100000);
       console.log('------');
   }
   ```
2. 内存泄漏：
   1. 占用的内存没有及时的释放；
   2. 内存泄漏积累多了就容易导致内存溢出；
   3. 常见的内存泄漏：(面试)
      1. 意外的全局变量；（没有用var 声明局部变量）
      2. 没有及时清理的计时器或回调函数;
      3. 闭包；
        ```
        (1) 意外的全局变量；
        function fn() {
             a = new Array(10000);
             console.log(a);
        }
        fn();
        ```
        (2)没有及时清理的计时器或回调函数
        ```
        var intervalId = setInterval(function () {
            console.log('-------');
        }, 1000)
        // clearInterval(intervalId);
        ```
        (3) 闭包
        ```
        function fn1() {
            var a = 4;
            function fn2() {
                console.log(a++);
            }
            return fn2;
        }
        var f = fn1();
        f();
        // f = null;
        ```
## 7. 递归
1. 概念：一个函数在内部可以调用其本身，那么这个函数就是递归函数；（函数内部自己调用自己）
2. 递归函数的作用和循环效果一样；
3. 由于递归很容易发生'栈溢出'错误(stack overflow)，所以必须要加退出条件 return；
   ```
    var num = 1;
    function fn() {
        console.log('我要打印6句话');
        if (num == 6) {
            return;// 递归必须加退出条件
        }
        num++;
        fn();
    }
    fn();
   ```
### 7.1 浅拷贝和深拷贝
   1. 浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用（地址值）：修改会影响原来的对象；
   2. 深拷贝拷贝多层，每一级别的数据都会被拷贝：修改不影响原来的对象；
   3. Object.assign(target,...sources) es6新增方法可以浅拷贝；
   ```
   // 1. 浅拷贝
   var obj = {
        id :1,
        name:'andy',
        msg:{
            age:18
        }
    };
    var o = {};
    for(var k in obj){
        // k 是属性名，obj[k] 属性值
        o[k] = obj[k];
    }
    console.log(o);
    o.msg.age = 20;// 会修改obj的对象，因为这两个对象指向同一个地址值；

    // Object.assign(target,...sources) es6新增方法可以浅拷贝
    Object.assign(o,obj);
    console.log(o);

    // 2. 深拷贝
    var obj = {
        id: 1,
        name: 'andy',
        msg: {
            age: 18
        },
        arr: [1, 2, 3]
    };
    var o = {};
    // 封装函数 利用递归
    function deepCopy(newobj, oldobj) {
        for (var k in oldobj) {
            // 先判断属性值属于哪种类型；
            // 1. 获取属性值oldobj[k]
            var item = oldobj[k];
            // 2. 判断这个值是否为数组
            if (item instanceof Array) {
                newobj[k] = [];
                deepCopy(newobj[k], item)
            } else if (item instanceof Object) {
                // 3. 判断这个值是否为对象
                newobj[k] = {};
                deepCopy(newobj[k], item);
            } else {
                // 4. 属于简单数据类型
                newobj[k] = item;
            }
        }
    }
    deepCopy(o, obj);
   ```
## 8. 闭包面试题
1. 题1：此时函数根本没有局部变量，没有闭包产生
   ```
   var name = 'The Window';
   var object = {
       name: 'My Object',
       getNameFunc: function () {
           return function () {
               return this.name;
           };
       }
   };
    console.log(object.getNameFunc()());// 输出 The Window
    // object.getNameFunc()() 类似于：
    // var f = object.getNameFunc(); 类似于：
    // var f = function () {
    //     return this.name;// 直接执行函数 this永远指向window
    // }
    // f();
   ```
2. 题2：调用了外部函数的that变量，产生了闭包；
   ```
   var name = 'The Window';
    var object = {
        name: 'My Object',
        getNameFunc: function () {
            var that = this; // 此时的this指向object，因为它是函数的调用者
            return function () {
                return this.name; //调用了外部函数的that变量，产生了闭包
            };
        }
    };
    console.log(object.getNameFunc()());// 输出 My Object
    // object.getNameFunc()() 类似于：
    // var f = object.getNameFunc(); 这个函数又有返回值 类似于：
    // var f = function () {
    //     return this.name;
    // };
    // f();
    ```
3. 终极闭包面试题：
    ```
    function fun(n, o) {
        console.log(o);
        return {
            fun: function (m) {
                return fun(m, n);
            }
        }
    }
    var a = fun(0);// undefined n =0,形成闭包，调用变量n为0，赋值给o = 0
    // 外部函数调用一次产生一次闭包，但是没有接收返回的对象，闭包死亡 还是用原来的a里面的闭包
    // 此时m=1, o没变 = 0
    a.fun(1);//0 
    a.fun(2);//0 同上
    a.fun(3);//0 同上 
    // 每次调用形成新闭包，调用变量m为几，o = 几
    var b = fun(0).fun(1).fun(2).fun(3);// undefined,0,1,2 
    var c = fun(0).fun(1); // undefined,0 ( m = 1, n = o = 0)
    c.fun(2);// 还是原来的闭包n为1 ，m=2,n = o = 1;
    c.fun(3);// 还是原来的闭包n为1，m = 3,n = o = 1
    ```