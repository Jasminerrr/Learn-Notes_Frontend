# 1. 函数的prototype属性
1. 每个函数都有一个prototype属性，它默认指向一个Object空对象（即称为：原型对象）；
2. 原型对象中有一个属性constructor（构造器），它指向函数对象；
3. 给原型对象添加属性（一般是方法）：
   1. 作用：函数的所有实例对象自动拥有原型中的属性（方法）（实例对象可以访问）；
```
    function Fun() {

    }
    console.log(Fun.prototype);// 默认指向一个Object空对象（没有我们的属性）
    // 原型对象中有一个属性constructor，它指向函数对象
    console.log(Fun.prototype.constructor === Fun);// true
    Fun.prototype.test = function () {
        console.log('test()');
    }
    var fun = new Fun();
    fun.test();// test()
```
# 2. 显式原型与隐式原型
1. 每个函数function都有一个prototype，即显式原型（属性），默认指向一个Object实例空对象；
2. 每个实例对象都有一个__proto__，可称为隐式原型（属性）；（一个实例对象可能有多个原型对象）
3. 对象的隐式原型的值 为 其对应构造函数的显式原型的值；（实例对象的隐式原型属性永远指向其缔造者的原型对象）
4. 先有构造函数的prototype，才有实例对象的__proto__；
5. 总结：
   1. 函数的prototype属性在定义函数时自动添加，默认值是一个空Object实例对象；
   2. 对象的__proto__属性是创建对象时自动添加，默认值为构造函数的prototype属性值；
   3. 程序员可以直接操作显式原型，但不能直接操作隐式原型（es6之前）；
```
    // 定义构造函数
    function Fn() {// 内部语句：this.prototype = {}

    }
    //1. 每个函数function都有一个prototype，即显式原型（属性），默认指向一个Object空对象
    console.log(Fn.prototype);// Object
    //2. 每个实例对象都有一个__proto__，可称为隐式原型（属性）
    // 创建实例对象
    var fn = new Fn();// 内部语句：this.__proto__ = Fn.prototype
    console.log(fn.__proto__);// Object
    //3. 对象的隐式原型的值为 其对应构造函数的显式原型的值
    console.log(Fn.prototype === fn.__proto__);// true
    // 给原型添加方法
    Fn.prototype.test = function () {
        console.log('test()');
    }
    //通过实例对象调用原型的方法
    fn.test();// test
```
# 3. 原型constructor构造函数
1. 对象原型(__proto__)和构造函数(prototype)原型对象里面都有一个属性constructor属性，称为构造函数，因为它指回构造函数本身；
2. constructor主要用于记录该对象引用于哪个构造函数；
3. 可以让原型对象重新指向原来的构造函数（修改了原来的原型对象，因为给原型赋值的是一个对象，把原来的覆盖掉了，则必须手动改回来）;
   ```
   function Star(uname, age) {
        this.uname = name;
        this.age = age;
    }
    // 手动利用constructor让原型对象重新指向原来的构造函数
    Star.prototype = {
        // 如果修改了原来的原型对象，给原型赋值的是一个对象，把原来的覆盖掉了，则必须手动改来
        constructor: Star,
        sing: function () {
            console.log('唱歌');
        },
        movie: function () {
            console.log('电影');
        }
    }
    var ldh = new Star('刘德华', 18);
    var zyx = new Star('张学友', 20);
    console.log(Star.prototype);
    console.log(ldh.__proto__);
    console.log(Star.prototype.constructor);
    console.log(ldh.__proto__.constructor);
    ```
# 4. 原型链（隐式原型链）
1. 访问一个对象的属性（方法）时：
   1. 会先在对象自身中寻找，找到则直接使用；
   2. 没有则沿着__proto__这条链向上寻找，如果找到则直接使用；
   3. 原型对象也是对象，它也有原型，如果没有则去原型的原型中找，直到找到Object对象的原型；
   4. Object对象的原型没有原型，如果在Object依然找不到，则返回undefined；
2. 作用：查找对象的属性（方法）；
![](../JavaScript基础/Learn%20notes/images/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg)
## 4.1 原型继承：
   1. 构造函数的实例对象自动拥有构造函数原型对象的属性（方法）；
   2. 也就是说原型对象上面的属性和方法是给实例用的，利用的就是整个原型链；
   3. 所有函数都是Function函数的实例对象，包括它本身：
      1. Function.__proto__ === Function.prototype;
   4. Object原型对象是原型链尽头；
   5. 例如a.b：找a变量是作用域链，找到后找b(是对象的属性)，在a对象的原型链上找，找不到返回undefined；
## 5. 原型链属性问题
1. 读取对象属性值时，会自动去原型链中查找；
2. 设置对象的属性值时，不会查找原型链，如果当前对象中没有属性，直接添加此属性并设置其值；
3. 方法一般定义在原型中，属性一般通过构造函数定义在对象本身；
```
    function Person(name, age) {
            this.name = name;
            this.age = age;
    }
    Person.prototype.setName = function (name) {
        this.name = name;// 这个this指向调用的对象p1 所以修改了原来的属性name
    }
    var p1 = new Person('Tom', 12);
    p1.setName('Bob');// 调用原型对象里面的方法
    console.log(p1.name);// Bob
```
## 6. instanceof是如何判断的
1. 表达式：A instanceof B ,判断实例对象A是否为构造函数B的实例对象；
2. 如果B函数的显示原型对象在A对象的原型链上（只要指向A得其中一个原型对象），是返回true,否返回false；
3. Function是通过new Function产生的；
4. 所有函数都是new Function产生的，所有函数都是Function函数的实例对象；
5. function Object，Object既是构造函数，又是Function的实例对象；
6. Object实例对象是new Object产生的，Object是Object函数的实例对象；
```
    //  图在本上
    function Foo() { }
    var f1 = new Function;//true
    var o1 = new Object();//true
    var o2 = {}
    console.log(f1 instanceof Foo);//true
    console.log(f1 instanceof Object);//true
    console.log(Object instanceof Function);//true
    console.log(Object instanceof Object);//true
    console.log(Function instanceof Function);//true
    console.log(Function instanceof Object);//true
    function Foo() { }
    console.log(Object instanceof Foo);//false
```
## 7. 原型面试题
1. 实例对象自动拥有构造函数原型对象的属性（方法）;
2. Object的原型对象是原型链尽头；
3. 测试1：（图在本上）
```
    function A() {

    }
    A.prototype.n = 1;
    var b = new A();
    A.prototype = {// 重新添加了一个对象赋值给了A的显示原型，原来的链断了
        n: 2,
        m: 3
    }
    var c = new A();
    console.log(b.n, b.m, c.n, c.m);// 1, undefined, 2, 3
```
4. 测试2：（图在本上）
```
    function F() { }
    Object.prototype.a = function () {
        console.log('a()');
    }
    Function.prototype.b = function () {
        console.log('b()');
    }
    var f = new F();
    f.a();// a()
    f.b();// undefined
    F.a();// a()
    F.b();// b()
```