## 1. 进程（process）
1. 概念：
   1. 程序的一次运行，它占有一片独有的内存空间；
   2. 可以通过window任务管理器查看进程；
2. 一个进程内的数据可以供其中的多个线程直接共享；
3. 多个进程之间的数据不能直接共享；
4. 多进程运行：一应用程序可以同时启动多个实例运行；
## 2. 线程（thread）
1. 概念：
   1. 是进程内的一个独立执行单元；
   2. 是程序执行的一个完整流程；
   3. 是CPU的最小调度单位；
2.  多线程：一个进程可以同时运行多个线程，会说程序是多线程运行的；
   1. 优点：能有效提高CPU的利用率；
   2. 缺点：
      1. 创建多线程开销；
      2. 线程间切换开销；
      3. 死锁与状态同步问题；
3. 单线程：
   1. 优点：顺序编程简单易懂；
   2. 缺点：效率低； 
## 3. 相关知识
1. 应用程序必须运行在某个进程的某个线程上；
2. 一个进程中至少有一个运行的线程：主线程（进程启动后自动创建）；
3. 线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用；
4. JS是单线程，但使用H5中的Web Workers可以多线程运行；
5. 浏览器都是多线程运行；
6. 浏览器是多进程还是单进程：
   1. 有的是单进程：老板IE；
   2. 有的是多进程：firefox，chrome，新版IE；
## 4. 浏览器内核
1. 支撑浏览器运行的最核心的程序；
2. 不同浏览器内核不一样：比如chrome 浏览器的 V8；
3. 内核由很多模块组成，如下：
4. 主线程：
   1. js引擎模块：负责js程序的编译与运行；
   2. html,css文档解析模块：负责页面文本的解析；
   3. DOM/CSS模块：负责dom/css在内存中的相关处理；
   4. 布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）；
5. 分线程：
   1. 定时器模块：负责定时器的管理；
   2. DOM事件模块：负责事件的管理；
   3. 网络请求模块：负责Ajax请求；
6. 问题1：定时器真是定时执行吗？
   1. 定时器并不能保证真正定时执行：如果在主线程执行了一个长时间的操作，可能导致延时才处理；
   2. 一般会延迟一丁点（可以接受），也有可能延迟很长时间（不能接受）；
7. 问题2：定时器回调函数是在分线程执行的吗？
   1. 在主线程执行的，因为js是单线程；
8. 问题3：定时器是如何实现的？
   1. 事件循环模型；
## 5. JS是单线程的
1. 如何证明js执行是单线程的？
   1. setTimeout()的回调函数是在主线程执行的；
   2. 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行；
2. 为什么js要用单线程模式，而不用多线程模式？（了解）
   1. JavaScript的单线程，与它的用途有关；
   2. 作为浏览器的脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM；
   3. 这决定了它只能是单线程，否则会带来很复杂的同步问题；
   4. 只能是主线程更新界面；
## 6. 事件处理机制
1. 代码的分类：
   1. 初始化代码；
   2. 回调代码；
2. js引擎执行代码的基本流程：
   1. 先执行初始化代码：包含一些特别的代码：
      1. 设置定时器(定时器回调函数不执行)；
      2. 绑定DOM事件监听（内部回调函数不执行，事件触发才执行）；
      3. 发送ajax请求；
   2. 后面在某个时刻才会执行回调代码；
   ```
    setTimeout(function () {
        console.log(2222);
    }, 2000)
    setTimeout(function () {
        console.log(1111);
    }, 1000)
    function fn() {
        console.log('fn');
    }
    fn();
    console.log('alert()之前');
    alert('-----');// 暂停当前主线程的执行，同时暂停计时，点击确定后 恢复程序执行和计时
    console.log('alert()之后');
   ```
## 6. 事件循环模型
1. 模型的两个重要组成部分：
   1. 事件管理模块；
   2. 回调队列；
2. 模型的运转过程：
   1. 执行初始化代码，将事件回调函数交给对应模块管理；
   2. 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中；
   3. 只有当初始化代码执行完后（可能要一定时间），才会遍历读取回调队列中的回调函数执行；
## 7. 相关重要概念
1. 执行栈（execution stack）：所有的代码都是在此空间执行的；
2. 浏览器内核(browser core)：
   1. js引擎模块：主线程处理；
   2. 其他模块：在主/分线程处理；
3. callback queue(回调队列)：都是指同一个 先进先出
   1. 任务队列：task queue;
   2. 消息队列：message queue；
   3. 事件队列：event queue;
4. 事件轮询(event loop)：从任务队列中循环取出回调函数放入执行栈中处理（一个接一个）；
5. 事件驱动模型：event-driven interacyion model；
6. 请求响应模型：request-response model；
## 8. H5 Web Workers(多线程)
1. H5规范提供了js分线程的实现，取名为Web Workers；
2. 可以将一些大计算量的代码交由给Web Worker运行而不冻结用户界面；
3. 子线程完全受主线程控制，且不得操作DOM(文档对象模型：页面元素)，这个新标准并没有改变JS单线程的本质；
4. 相关API：
   1. Workers：构造函数，加载执行分线程执行的js文件；
   2. Workers.prototype.postMessage：向另一个线程发送消息；
   3. Workers.prototype.onmessage：用于接收另一个线程的回调函数；
5. 缺点：
   1. 慢；（操作变多，但是可以让主线程不被冻结继续操作，提高用户体验）
   2. 不能跨域加载JS；
   3. worker内代码不能访问DOM（更新UI）：因为它的全局对象不再是window，再分线程中不可能更新界面；
   4. 不是每个浏览器都支持这个新特性；
   ```
   var worker = new Worker('worker.js');
     worker.onmassage = function (event) {// 用来接收另一个线程发送过来的数据的回调
         event.data;// 取数据
     }
     worker.postMessage(data1);// 向另一个线程发送数据
   ```


