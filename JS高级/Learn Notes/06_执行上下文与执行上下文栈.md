## 1. 变量提升与函数提升（预解析）
1. js引擎会把js里面所有的 var 和 function 提升到当前作用域的最前面；
2. 变量提升：
   1. 就是把所有声明的变量提升到当前作用域的最前面，不提升赋值操作；
3. 函数提升：
   1. 把所有的函数声明提升到当前作用域的最前面，不调用函数；
   2. 函数表达式声明必须写在函数下面。
   3. 必须是通过声明的方式（命名函数），函数表达式复制的变量是变量提升，与变量值无关；
4. 先变量提升再函数提升（函数提升优先级高于变量提升，指函数提升的时间晚）；
## 2. 执行上下文
1. 代码分类（位置）：全局代码/函数（局部）代码；
2. 执行上下文对象是 n + 1 原则，n是调用几次函数，1 是window；
3. 全局执行上下文：
   1. 在执行全局代码前将window确定为全局执行上下文；
   2. 对全局数据进行预处理：
      1. var 定义的全局变量 添加为window的属性，值为undefined；
      2. function声明的全局函数（值为函数对象fn） 添加为window的方法；
      3. this 指向 window（函数调用指向window，方法调用指向当前调用方法的对象）；
      4. 开始执行全局代码；
4. 函数执行上下文：即为this指向
   1. 在调用函数，准备执行函数体之前，创建对应的 函数执行上下文对象（虚拟的，存在于栈中，封闭的外面不能访问）；意思就是 调用一次函数，产生一个函数执行上下文对象；
   2. 对局部数据进行预处理：
      1. 形参变量-进行赋值（实参），然后添加为执行上下文的属性；
      2. arguments内置对象-赋值（所有实参），然后添加为执行上下文的属性；
      3. var 定义的局部变量 添加为执行上下文的属性，值为undefined；
      4. function声明的局部函数-赋值（函数对象fn）（里面的函数不执行），然后添加为执行上下文的方法；
      5. this 指向调用函数的对象；
   3. 开始执行函数体代码；
5. 执行函数定义：定义函数，不执行函数体，只是创建函数对象；
6. 执行：函数名()，是执行函数对象；
## 3. 执行上下文栈
1. 在全局代码执行前，JS引擎就会执行一直栈来储存管理所有的执行上下文对象；
2. 在全局执行上下文(window)确定后，将其添加到栈中（栈最底层）；
3. 在函数执行上下文创建后，将其添加到栈中（栈：后进先出，队列：先进先出）；
4. 当前函数执行完后，将栈顶的对象移除（出栈）（当前执行永远是栈顶的那个，函数执行完自动释放）；
5. 所有的代码执行完后，栈中只剩下window； 
6. 测试：（面试题）
   1. 依次输出什么？
      1. gb：undefiend；
      2. fb：1；
      3. fb：2；
      4. fb：3；
      5. fe：3；
      6. fe：2；
      7. fe：1；
      8. ge：1；
   2. 整个过程中产生了几个执行上下文？ 5个：window,fb(1),fb(2),fb(3),fb(4)；
```
    console.log('gb' + i);// undefiend
    var i = 1;
    foo(1);
    function foo(i) {
        if (i == 4) {
            return;
        }
        console.log('fb' + i);// 1 2 3
        foo(i + 1);// 递归调用：在函数内部调用自己（一层一层调用）
        console.log('fe' + i);// 3 2 1
    }
    console.log('ge' + i);//1
```
7. 测试题1：先执行变量提升，再执行函数提升
   ```
    function a() { }
    var a;
    console.log(typeof a);// 'function'
   ```
8. 测试题2:
   ```
    if (!(b in window)) {// 先 var b; 再有if语句 此时b已经在window里面 为false
        var b = 1;// 为false 不执行
    }
        console.log(b);// undefined
   ``` 
9. 测试题3：
   ```
    var c = 1;// var a;
    function c(c) {
        console.log(c);
        var c = 3;
    }
    // c = 1; c被赋值是一个number的基本数据类型 已经不是函数了
    c(2); // 报错 c此时不是函数，不能调用

   ```