## 1. Object构造函数模式
1. 方式：先创建空对象Object，再动态添加属性/方法；
2. 适用场景：创建一个对象，起始时不确定对象内部数据；
3. 缺点：语句太多；
   ```
   // 先创建空Object对象
   var obj = new Object();// 也可以写成 var obj = {}
   obj = {}; // 此时内部数据不确定
   // 再动态添加属性/方法
   obj.name = '张三';
   obj.age = 18;
   obj.sayHi = function() {
       console.log('hi');
   }
   // 测试
   console.log(obj.name);
   console.log(obj['age']);
   obj.sayHi();
   ```
## 2. 对象字面量模式
1. 方式：使用{}创建对象， 同时指定属性/方法；
2. 适用场景：创建一个对象，起始时对象内部的数据是确定的；
3. 缺点：创建多个对象时，会有重复代码；
   ```
   // 1. 创建对象
    //var obj = {};// 创建了一个空对象 
    var obj = {
        uname: '张三',
        age: 18,
        sex: '男',
        sayHi: function() {
            console.log('hi');
        }
    }
    //2. 使用对象：
    //方法1：调用对象的属性 ，采取 对象名.属性名； . 理解为 的；
    console.log(obj.uname);
    //方法2： 对象名['属性名']
    console.log(obj['age']);
    //3. 调用对象的方法：sayHi  对象名.方法名()；（千万别忘记添加小括号）
    obj.sayHi();
   ```
## 3. 工厂模式（了解）
1. 方式：通过工厂函数动态创建对象并返回；（工厂函数：返回一个新对象的函数）
2. 适用场景：需要创建多个对象；
3. 缺点：对象没有一个具体的类型，都是Object类型；（比如人和狗不是一个类型）
   ```
   function createPerson(name, age) {
        var obj = {
            name: name,
            age: age,
            setName: function (name) {
                this.name = name
            }
        }
        return obj;
    }
    // 创建一个人
    var p = createPerson('Tom', 12);
   ```
## 4. 自定义构造函数模式
1. 方式：自定义构造函数，通过new创建对象；
2. 适用场景：需要创建多个类型确定的对象；
3. 每一个函数对象都有一个不可修改的属性叫name，name的值就是函数的名字，只读不可改;(面试)
   ```
    function Fn(){
    }
    Fn.name = 'tom';
    console.log(Fn.name);// Fn
   ```
4. 缺点：每个对象都有相同的数据，浪费内存；（相同的方法，但隐式原型都指向同一个原型对象）
   ```
   function Person(name, age) {
        this.name = name;
        this.age = age;
        this.setName = function (name) {
            this.name = name;
        }
    }
    var p1 = new Person('Tom', 12);
    p1.setName('Jack');
    console.log(p1.name, p1.age);
    console.log(p1 instanceof Person);//true 
   ```
## 5. 构造函数+原型的组合模式
1. 方式：自定义构造函数，属性在函数中初始化，方法添加到原型上；
2. 适用场景：需要创建多个类型确定的对象；
   ```
   function Person(name, age) {// 构造函数中只初始化一般属性
        this.name = name;
        this.age = age;
    }
    Person.prototype.setName = function (name) { // 方法添加在原型上面
        this.name = name;
    }
    var p1 = new Person('Tom', 12);
    var p2 = new Person('Jack', 13);
    console.log(p1, p2);
   ```
## 6. new 一个对象背后做了什么？
1. 创建一个空对象；（this指向这个对象）
2. 给对象设置__proto__，值为其构造函数的prototype属性值(this.__proto__ = Fn.prototype)；
3. 执行构造函数体（给对象添加属性/方法）；