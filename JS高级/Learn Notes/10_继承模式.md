## 1. 原型链继承：得到方法
1. 定义父类型构造函数;
2. 给父类型的原型添加方法;
3. 定义子类型的构造函数;
4. 创建父类型的对象,赋值给子类型的原型;
5. 将子类型原型的构造属性设置为子类型;(constructor)
6. 创建子类型的实例对象;
7. 重点:子类型的原型为父类型的一个实例对象;
   ```
   // 1. 父构造函数
    function Father() {
        // this指向父构造函数的对象实例
    }
    Father.prototype.money = function () {// 共享的方法写在原型对象里面
        console.log(1000);
    };
    // 2. 子构造函数
    function Son(score) {
        // this指向子构造函数的对象实例
        this.score = score;
    }
    Son.prototype = new Father();// 实例化父构造函数(创建father实例对象),此对象可以Father的显示原型对象(Father.__proto__ = Father.prototype) 最终是为了能看到父类型的方法

    // 如果利用对象的形式修改了原型对象,要利用constructor指回原来的构造函数
    Son.prototype.constructor = Son;
    // 这是子构造函数专门的方法
    Son.prototype.exam = function () {// Son修改自己原型对象上的方法不会影响Father原型对象
        console.log('孩子要考试');
    }
    var son = new Son(100);// 有money方法
    console.log(son);
    console.log(Father.prototype);
   ```
## 2. 借用构造函数继承(假继承)：得到属性
1. 定义父类型构造函数;
2. 定义子类型构造函数;
3. 重点:在子类型构造函数中通过call()调用父类型构造函数;
4. 核心原理:通过call()把父类型的this指向子类型的this,实现子类型继承父类型的属性;
   ```
   function Father(uname, age) {
        // this指向父构造函数的对象实例
        this.name = name;
        this.age = age;
    }
    Father.prototype.money = function () {
        console.log(1000);
    };
    
    // 2. 子构造函数
    function Son(uname, age, score) {
        // this指向子构造函数的对象实例
        // 得到属性：call() 可以让一个函数成为指定任意对象的方法进行调用 相当于:this.Father(name, age)
        Father.call(this, uname, age); 
        this.score = score;
    }
    var son = new Son('Tom', 18, 100);
    console.log(son);
   ```
## 3. 组合继承 （构造函数+原型链）
1. 初始化属性数据用call();
2. 指定子类型的原型为父类型的实例对象；
   ```
   // 1. 父构造函数
    function Father(uname, age) {
        // this指向父构造函数的对象实例
        this.name = name;
        this.age = age;
    }
    Father.prototype.setName = function (name) {// 共享的方法写在原型对象里面
        this.name = name;
    };
    // 2. 子构造函数
    function Son(uname, age, score) {
        // this指向子构造函数的对象实例
        // 得到属性：call() 可以让一个函数成为指定任意对象的方法进行调用 相当于:this.Father(name, age)
        Father.call(this, uname, age); 
        this.score = score;
    }
    Son.prototype = new Father();// 实例化父构造函数(创建father实例对象),此对象可以Father的显示原型对象(Father.__proto__ = Father.prototype) 最终是为了能看到父类型的方法
    // 如果利用对象的形式修改了原型对象,要利用constructor指回原来的构造函数
    Son.prototype.constructor = Son;
    // 这是子构造函数专门的方法
    Son.prototype.setPrice = function (price) {// Son修改自己原型对象上的方法不会影Father原型对象
        this.price = price;
    }
    var son = new Son('Tom', 18, 100);
    son.setName('Bob');
    s.setPrice(12000);
    console.log(s.name, s.age, s.price);
   ```