# 1. ES6中的类和对象
1. 面向对象的思维特点：
   1. 抽取（抽象）对象共用的属性和行为 组织（封装）成一个类（模板）；
   2. 对类进行实例化，获取类的对象；
   3. 不断的创建对象，使用对象，指挥对象做事情；
## 1.1 对象
   1. 对象：在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。
   2. 对象是由属性和方法组成的。
      1. 属性：事物的特征，在对象中用属性来表示（常用名词）；
      2. 方法：事物的行为，在对象中用方法来表示（常用动词）；
   3. 对象可以让结构表达更清晰。
# 2. 类 class
   1. 在ES6中新增了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象；
   2. 类抽象了对象的公共部分，泛指某一大类；
   3. 对象特指某一个，通过类实例化一个具体的对象；
## 2.1 创建类
   1. 语法：类必须使用new实例化对象；
   2. es6中没有变量提升，所以必须先定义类，才能通过类实例化对象；
   3. 类里面 共有的属性和方法一定要添加this使用；
   4. 语法格式：
      ```
      class name {
         // class body
      }
      // 创建实例
      var xx = new name();
      ```
## 2.2 类constructor构造函数
   1. constructor() 方法是类的构造函数(默认方法)，用于传递参数,返回实例对象(不需要return)；
   2. constructor函数只要new生成实例时，就会自动调用这个函数，不写这个函数，类也会自动创建一个没有参数的构造函数；
   3. 类里面至少要有一个constructor 函数，可以接收传递过来的参数，同时返回实例对象；
   4. constructor里面的this指向的是 创建的实例对象；
## 2.3 类添加方法
   1. 书写方式：
      1. 通过class关键字创建类，类名习惯性定义首字母大写，类名后面没有小括号；
      2. 类里面所有的函数不需要加function，多个函数方法之间不能加逗号分隔；
      3. 生成实例的类名后面要加小括号；
   4. 类里面 共有的属性和方法一定要添加this使用；
   5. 方法里面的this指向的是 这个方法的调用者；
   ```
   // (1) 创建类 class 创建一个明星类
   class Star {
      constructor(uname, age) {
         this.name = name;
         this.age = age;
         // 可以直接在构造函数里面调用方法 要加this 指实例对象
         this.say();
      }
      // (3)添加方法
      sing(song){
         console.log(this.name + song);
      }
      say(){
         console.log(this.age);
      }
   }
   // (2) 利用类创建对象 new
   let ldh = new Star('刘德华', 18);
   let zxy = new Star('张学友', 19);
   console.log(ldh);
   console.log(zxy);
   // 调用方法
   ldh.sing('冰雨');
   zyx.sing('李香兰');
   ```
## 2.4 类的静态成员
   1. 声明关键字：static；
   2. static通过 [类名.方法名] 访问；
   3. static标注的属性和方法：属于类，而不属于实例对象；
   ```
   class Phone{
      // 静态成员
      static name = '手机';
      static change(){
          console.log('aaaaaaa');
      }
   }
   let nokia = new Phone();
   console.log(nokia.name);// undefined
   console.log(Phone.name);// 手机
   ```
# 3. 类的继承(extends)
1. 子类可以继承父类的一些属性和方法；
2. 继承中的属性/方法查找原则：就近原则；
   1. 如果实例化子类输出一个方法，先看子类有没有此方法，如果有，则先执行子类的；
   1. 如果没有，就去查找父类，找到则执行父类的方法；
   ```
   class Father{
      constructor()
      }
      money(){
          console.log(100);
      }
   }
   class Son extends Father{
   }
   let son = new Son();
   son.money();
   ```
# 3.1 super关键字
1. super关键字用于访问和调用对象父类上的函数(构造函数、普通函数)；
2. 利用super将子类中的constructor数据传给父类；
3. 子类在构造函数中使用super时，必须放到this前面；（必须先调用父类构造方法，再使用子类的构造方法）
4. 子类不能调用父类同名方法；
   ```
   // (1) 调用父类中的构造函数
   class Father{
      constructor(x,y){
          this.x = x;
          this.y = y;
      }
      sum(){
          console.log(this.x + this.y);
      }
   }
   class Son extends Father{
      constructor(x,y){
          super(x,y); // 调用父类中的构造函数
      }
   }
   let son = new Son(1,2);
   let son1 = new Son(22,11);
   son.sum();// 3
   son1.sum();// 33

   // (2) 调用父类中的普通函数
   class Father{
       say(){
           return '我是爸爸';
       }
   }
   class Son extends Father{
       say(){
         // super.say() 就是调用父类中的普通函数
           console.log(super.say()+ '的儿子');
       }
   }
   let son = new Son(1,2);
   son.say();// 我是爸爸的儿子
   ```
# 4. 类里面的getter和setters设置
1. get和set是js对象中的访问器属性，介于属性和方法之间，一般成对出现，只存在于ES6中：
   1. 如果只有get，表示该属性只可读，不可写；
   2. 如果只有set，表示该属性只可写，不可读；
2. get：
   1. 不能有参数，且必须用return返回，函数的返回值就是属性的值；
   2. 读取属性的时候执行函数；
   3. 一般对对象动态的属性进行封装；
3. set：有且仅有一个参数，赋值的时候执行函数；
   ```
   class Phone{
       get price(){
           console.log('价格属性被读取');
           return 'aaaa';
       }
       set price(newValue){// set 只能有一个参数
           console.log('价格属性被修改');
       }
   }
   // 实例化对象
   let s = new Phone();
   s.price = 'free';// 赋值的时候执行函数
   ```