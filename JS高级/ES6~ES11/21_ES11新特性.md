# 1. 面向对象的私有属性
1. 类里面的私有属性外面访问不到；
   ```
    class Person{
        // 共有属性
        name;
        // 私有属性
        #age;
        #weight;
        // 构造方法
        constructor(name,age,weight){
            this.name = name;
            this.#age = age;
            this.#weight = weight;
        }
        intro(){
            console.log(this.name);
            console.log(this.#age);
            console.log(this.#weight);
        }
    }
    // 实例化
    const bob = new Person('Bob',20,'50kg');
    // console.log(bob.name);
    // console.log(bob.#age);// 只能出现在类内部，外部不能访问
    // console.log(bob.#weight);
    bob.intro();
   ```
# 2. Promise.allSettled()方法
1. allSettled()：
   1. 接收一个Promise的数组；
   2. 返回结果为Promise对象；
   3. 并且返回结果永远是成功的状态，返回的值是里面每一个Promise的状态和结果；
   4. allSettled()方法无论数组中的Promise成功还是失败，都会全部执行完；
2. all()方法：
   1. 也是接收一个Promise对象；
   2. 返回结果根据里面每一个Promise对象的状态和值决定；
      1. 都成功，则成功；
      2. 有一个失败，则返回失败；
3. 适用场景：都用来做一些批量异步任务；
   ```
    // 声明2个Promise对象
    const p1 = new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve('商品数据 - 1');
        },1000);
    });
    const p2 = new Promise((resolve,reject)=>{
        setTimeout(()=>{
            reject('商品数据 - 2');
            // reject('出错啦');
        },1000);
    });
    // 调用allsettled方法
    const result = Promise.allSettled([p1,p1]);
    
    // 调用all()方法
    // const res = Promise.all([p1,p2]);
    // console.log(res);
   ```
# 3. String.prototype.matchAll()方法
1. matchAll()：用来得到正则批量匹配的结果，
2. 使用场景：正则匹配提取数据；
   ```
    // 声明一个字符串
    let str = `
    <ul>
        <li>
            <a>肖生克的救赎</a>
            <p>上映时间：1994-09-10</p>
        </li>
        <li>
            <a>阿甘正传</a>
            <p>上映时间：1994-07-06</p>
        </li>
    </ul>
    `;
    // 声明正则
    // 全局匹配
    const reg = /<li>.*?<a>(.*?)<\/a>.*?<p>(.*?)<\/p>/sg;
    // 调用方法
    const result = str.matchAll(reg);
    // for(let v in result){
    //     console.log(v);
    // }
    const arr= [...result];
    console.log(arr);
   ``` 
# 4. 可选链操作符
1. 可选链操作符是[?.]的组合；
2. 使用场景：在对象类型的参数时，深度很深，不用再做层级的判断；
   ```
    function main(config){
        // && 表达式：
        //     返回第一个为false的值，并不再看后面的值；
        //     全为true,则返回最后一个为true的值
        // const dbHost = config && config.db && config.db.host;
        const dbHost = config?.db?.host;
        console.log(dbHost);
    }
    main({
        db:{
            host:'192.168.1.100',
            username:'root'
        },
        cache:{
            host:'192.168.1.200',
            username:'admin'
        }
    })
   ```
# 5. 动态import
1. 动态导入可以提高加载效率；
2. improt返回的是Promise对象；
   ```
   // 静态导入：
   import *  as m3 from "./m3.js";
   // 动态导入：
    const btn = document.querySelector('button');
    btn.onclick = function(){
        import('./m1.js').then(module=>{
            module.school();
        });
    }
   ```
# 6. BigInt
1. BigInt大整形：用来进行更大的数值运算；
2. 表达方式：在[普通整形数字]基础上后面加n；
3. BigInt函数：可以把[普通整数]的值转化为[大整形]的值；
   ```
    // 大整形
    let n = 123n;
    console.log(n, typeof (n));// 123n "bigint"
    // 函数
    let m = 123;
    console.log(BigInt(n));// 123n
    // 大数值运算
    let max = Number.MAX_SAFE_INTEGER;
    console.log(max);
    console.log(max + 1);
    console.log(BigInt(max));
    console.log(BigInt(max)+ BigInt(1));
   ```
# 7. 绝对全局变量globalThis
1. 始终指向全局对象，不论什么环境（浏览器或node.js）；
2. 作用：在写代码时，如果想对全局对象进行操作，可以忽略环境，直接使用globalThis；
