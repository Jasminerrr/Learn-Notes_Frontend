# 1. 事件的基本使用（案例03）
1. 绑定事件监听：[v-on:xxx]，简写[@xxx]，xxx为事件名(click等)；
2. 事件的回调需要配置在methods对象中，最终会在vm上；
3. 语法：methods:{回调函数}
   1. methods中配置的函数，不要用箭头函数，否则this指向不再是vm；
   2. methods中配置的函数，都是被Vue所管理的函数，this指向是vm或组件实例对象；
4. @click = "demo" 和 @click = "demo($event)"效果一致，但后者可以传参；
5. 绑定事件加不加()都可以，但在插值语法里面调用方法要加()；
# 2. 事件修饰符
1. prevent：阻止默认事件（常用）；
2. stop：阻止事件冒泡（常用）；
3. once：事件只触发一次（常用）；
4. capture：使用事件的捕获模式；
5. self：只有event.target是当前操作的元素时，才触发事件；
6. passive：事件的默认行为立即执行，无需等待事件回调执行完毕；
7. 修饰符技巧：
   1. 可以连续写；
# 3. 键盘事件
1. 常用按键别名：
   1. 回车：enter；
   2. 删除：delete（捕获"删除"和"退格"键）；
   3. 退出：esc；
   4. 空格：space：
   5. 换行：tab（特殊，必须配合keydown使用）；
   6. 上：up；
   7. 下：down；
   8. 左：left；
   9. 右：right；
2.  Vue未提供别名的按键：
    1.  可以使用按键原始的key值去绑定；
    2.  注意要转为kebab-case(短横线命名)；
3. 系统修饰键（用法特殊）：ctrl、alt、shift、mete(win键)：
   1. 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发；
   2. 配合keydown使用：正常触发事件；
   3. 小技巧：一起用(@keyup.ctrl.y)；
4. 使用keyCode去指定具体的按键（不推荐）；
5. Vue.config.keyCodes.自定义键名 = 键码，可以定制按键别名（不推荐）；
# 4. 计算属性(案例05)
1. 定义：要用的属性不存在，要通过[已有属性]计算得来；
2. 原理：底层截住了Object.defineproperty方法提供的getter和setter；
3. 语法：
   1. computed:{计算属性}；
   2. 必须有返回值；
4. get什么时候调用：
   1. 初次读取计算属性时会执行一次；
   2. 当所依赖的数据发生变化时会被再次调用；
5. set：当计算属性被修改时，set调用；
6. 计算属性里面不能开启异步任务，因为要靠返回值；
7. 优势：与methods相比，内部有缓存机制(复用)，效率更高，调试方便；
8. 注意：
   1. 计算属性最终会出现在vm上，直接读取使用即可；
   2. 如果计算属性要被修改，必须要写set函数去响应修改，且set中要引起计算时所依赖的数据发生变化；
# 5. 监视属性（案例06）
1. 语法：watch:{被监视的属性}；
2. 当被监视的属性变化时，回调函数(handler)自动调用，进行相关操作；
3. immediate:true：初始化的时候让handler调用一下；
4. 监视的属性必须存在，才能进行监视；
5. 监视的两种写法：
   1. new Vue时传入watch配置；
   2. 通过vm.$watch监视（vm身上自带的方法）；
6. 监视简写：只有handler时候才能简写；
## 5.1 深度监视（案例06）
   1. Vue中的watch默认不监视对象内部值得改变（一层）；
   2. 配置deep:true可以监视对象内部值改变（多层）；(默认false)
   3. 注意：
      1. Vue自身可以监视对象内部值得改变，只是Vue提供得watch默认不可以；
      2. 使用watch时，根据数据的具体结构，决定是否采用深度监视；
## 5.2 computed和watch之间的区别(案例07)
   1. computed能完成的功能，watch都可以完成；
   2. 但是watch可以进行异步操作；
   3. 注意：
      1. 被Vue管理的函数，最好写成普通函数，这样this指向才是vm　或　组件实例对象；
      2. 不被Vue管理的函数（定时器／ajax/Promise的回调函数），最好写成箭头函数，为了让this指向是vm　或　组件实例对象；
# 6. 绑定样式
1. 在应用界面中，某些元素的样式是变化的；
2. class/style绑定就是专门用来实现动态样式效果的技术；
## 6.1 class样式(常用)
      1. 写法：[:class = "xxx"],xxx可以实字符串、对象、数组；
      2. 字符串写法："classA"样式的类名不确定，需要动态指定；
      3. 数组写法：["classA","classB"]要绑定的样式个数和名字不确定；
      4. 对象写法：{classA:isA,classB:isB}要绑定的样式个数和名字确定，但要动态决定用不用；
## 6.2 style样式
      1. :style = "{fontSize:xxx}"，xxx是动态值；
      2. :style = "[a,b]"，其中a/b是样式对象(key要是存在的css属性，不能瞎写)；
# 7. 条件渲染
## 7.1 v-show
   1. 动态控制节点是否展示；
   2. 写法：v-show = "表达式"；
   3. 适用于：切换频率较高的场景；
   4. 特点呢：不展示的DOM元素未被移除，仅仅只是使用样式隐藏；
   5. 注意：使用v-if时，元素可能无法获取到，而v-show一定能获取到；
## 7.2 v-if 
   1. 动态控制节点是否存在；
   2. 写法：
      1. v-if = "表达式"；
      2. v-else-if = "表达式"；
      3. v-else = "表达式"；
   3. 适用场景：切换频率较低的场景；
   4. 特点：不展示的DOM元素会直接被移除；
   5. 注意：
      1. v-if可以和v-else-if、v-else一起使用，但v-if一定要是最开始使用，且要求结构不能被'打断'；
      2. 使用v-if时，元素可能无法获取到，而v-show一定能获取到；
   6. v-if 和 template配合使用：template不会影响页面结构；
# 8. 列表渲染
## 8.1基本列表 v-for 指令
   1. 用于展示列表数据；
   2. 语法：
      1. v-for = "(item, index) in xxx" :key = "yyy"；
      2. :key：只要用遍历生成多个同样结构的数据，必须用:key给节点打标识(唯一的标识)；
   3. 可遍历：数组、对象、字符串（少）、执行次数（少）；
### 8.1.1 面试题：react、vue中的key有什么作用？（key的内部原理）
   1. 虚拟DOM中key的作用：
      1. key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】；随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：
   2. 对比规则：
      1. 旧虚拟DOM找到了与新虚拟DOM相同的key:
           1. 若虚拟DOM中内容没变，直接使用之前的真实DOM；
           2. 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真是DOM；
      2. 旧虚拟DOM中未找到与新虚拟DOM相同的key；则创建新的真实DOM，随后渲染到页面；
   3. 用index作为key可能会引发的问题：
      1. 若对数据进行 逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真是DOM更新——界面效果没问题，但效率低；
      2. 如果结构中还包含输入类的DOM：会产生错误DOM更新——界面有问题；
   4. 开发中如何选择key:
      1. 最好使用每条数据的唯一标识作为key：id、手机号、身份证号、学号等唯一值；
      2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的；
## 8.2 Vue.set()
   1. 语法：
      1. Vue.set(target,propertyName/index,value)；
      2. vm.$set(target,propertyName/index,value)；
      3. 返回值：设置的值；
   2. 用法：向响应式对象中添加一个property，并确保这个新property同样也是响应式的，且触发试图更新；
   3. 注意：对象不能是Vue实例，或者Vue实例的跟数据对象（data/_data）；
## 8.3 Vue检测数据的原理
   1. Vue会监视data中所有层次的数据；
### 8.3.1 监测对象中的数据
   1. 通过setter实现监控，且要在new Vue时就传入要监测的数据；
   2. 对象中后追加的属性，Vue默认不做响应式处理；
   3. 如需给后添加的属性做响应式，使用如下API：
      1. Vue.set(target,propertyName/index,value)；
      2. vm.$set(target,propertyName/index,value)；
### 8.3.2 监测数组中的数据
   1. Vue将侦听数组的变更(改变)方法进行了包裹(加工)，
      1. 调用原生对应的方法对数组进行更新；
      2. 重新解析模板，进而更新页面；
   2. 在Vue修改数组中的某个元素一定要用如下方法；
      1. push()：在末尾增加
      2. pop()：删除最后一个；
      3. shift()：删除第一个；
      4. unshift()：在首位增加；
      5. splice()：替换/截取；
      6. sort()：排序；
      7. reverse()：翻转；
# 9. 收集表单数据
1. input表单类型为[text]，v-model默认收集的是value值，则用户输入的就是value值；
2. input表单类型为[radio(单选)]，因为v-model默认收集的是value值，则要给标签配置value值；
3. input表单类型为[chackbox(多选)]:
   1. 没有配置value属性，则v-model收集的是checked(勾选/未勾选，为布尔值)；
   2. 配置value属性：
      1. v-model的初始值为非数组，则收集的是checked(勾选/未勾选，为布尔值)；
      2. v-model的初始值为数组，则收集的就是value组成的数组；
4. [v-model]的三个修饰符:
   1. lazy：失去焦点再收集数据；
   2. number：输入字符串转为有效的数字；
   3. trim：输入首尾空格过滤；
# 10. 过滤器
1. 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑处理）；
2. 语法：
   1. 注册过滤器：
      1. Vue.filter(name,callback)；(全局过滤器)
      2. new Vue{filters:{}}；(局部过滤器)
   2. 使用过滤器：
      1. {{xxx | 过滤器名}}；
      2. v-bind：属性 = "xxx | 过滤器名";
3. 注意：
   1. 过滤器也可以接收额外参数，多个过滤器间可以串联；
   2. 并没有改变原本的数据，是产生新的对应的数据；
   3. this指向window；
# 11. 内置指令
1. 所有指令相关的this都是window，因为不需要vm相关资源(操作了DOM，只有window才能操作)
## 11.1 v-text
   1. 作用：向其所在的节点中渲染文本内容；
   2. 与插值语法的区别：
      1. v-text会替换掉节点中的内容(不支持结构解析)，{{xxx}}则不会；
      2. 有些时候插值语法写起来更灵活；
   3. 语法：<div v-text="n"></div>
## 11.2 v-html
   1. 作用：向指定节点中渲染包含html结构的内容；
   2. 语法：<div v-html="str"></div>
   3. 与插值语法的区别：
      1. v-html会替换掉节点中的内容，{{xxx}}则不会；
      2. v-html可以识别html结构；
   4. 严重注意：v-html有安全性问题；
      1. 在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击；
      2. 一定要在可信的内容上使用v-html，永远不要用在用户提交的内容上；
## 11.3 v-cloak(没有值)
   1. 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性；
   2. 用法：
      1. 引入外部文件在body最底部时，可以解决网速慢时页面展示出插值语法模板未解析的问题；
      2. 使用css(display:none;)配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题；
## 11.4 v-once(没有值)
   1. v-once所在节点在初次动态渲染后，就视为静态内容了；
   2. 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能；
## 11.5 v-pre(没有值)
   1. 可以跳过所在节点的编译过程；
   2. 可利用它跳过：没有使用指令语法、插值语法的节点，会加快编译；
# 12. 自定义指令
1. 局部指令：
   ```
   new Vue({
      directives:{
         指令名:配置对象
      }
   })
   // 简写
   new Vue({
      directives:{
         指令名(){回调函数}
      }
   })
   ```
2. 全局指令：
   ```
   Vue.directive('指令名',对象或函数)
   ```
3. 配置对象中常用的3个回调：
   1. bind：指令与元素成功绑定时(一上来)调用；
   2. inserted：指令所在元素被插入页面时调用；
   3. update：指令所在的模板被重新解析时调用；
4. 注意：
   1. 定义指令时不加 v-，但使用时要加v-；
   2. 指令名如果是多个单词，要使用kebab-case(短横杠)命名方式，不要用camelCase(驼峰)命名；
# 13. 生命周期 
1. 又名：生命周期回调函数、生命周期函数、生命周期钩子；
2. 是什么：是Vue在关键时刻帮我们调用的一些特殊名称的函数；
3. 常用的生命周期钩子：
   1. mounted(初始化操作)：发送Ajax请求、启动定时器、绑定自定义事件、订阅消息等；
   2. beforeDestroy(收尾工作)：清除定时器、解绑自定义事件、取消订阅消息等；
4. 关于销毁Vue实例：
   1. 销毁后借助Vue开发者工具看不到任何信息；
   2. 销毁后自定义事件会失效，但原生DOM事件依然有效；
   3. 一般不会在beforeDestroy操作数据，因为即使操作诗句，也不会再触发更新流程了；
5. 注意：
   1. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的；
   2. 生命周期函数中的this指向是vm 或 组件实例对象；
6. 8个生命周期钩子：
   1. beforeCreate：无法通过vm访问到data中的数据、methods中的方法(初始化：生命周期、事件，但数据代理还未开始)；
   2. created：可以通过vm访问到data中的数据、methods中的方法(初始化：数据监测、数据代理)；
   3. befroreMount：页面呈现的是未经Vue编译的DOM结构，所有对DOM的操作，最终都不奏效；
   4. mounted：页面呈现的是经过Vue编译的DOM，对DOM的操作均有效(尽可能避免)；
   5. beforeUpdate：数据是新的，但页面是旧的(页面还没有和数据保持同步)；
   6. update：数据是新的，页面也是新的(页面和数据保持同步)；
   7. beforeDestroy：vm中所有数据：data、methods、指令等 都处于可用状态，马上要执行销毁过程；
7. 面试点：
   1. 哪个生命周期钩子中页面和数据尚未保持同步？
      1. beforeUpdate；

