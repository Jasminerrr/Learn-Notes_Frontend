## 1. 操作元素（元素都是可读写的）
### 1.1 改变元素内容
   1. element.innerText:从起始位置到终止位置的内容;
   2. element.innerHTML:丛起始位置到终止位置的全部内容;（常用这个 适于普通元素）
   2. innerText 和 innerHTML的区别:
      1. innerText：不识别html标签；非标准 空格和换行也会去掉；
      2. innerHTML：识别HTML标签；W3C标准 同时保留空格和换行;
      3. 两个属性是可读写的，可以获取元素里面的内容；
      var p = document.querySelector('p');
      onsole.log(p.innerText);
   ```
   <button>显示当前系统时间</button>
   <div>某个时间</div>
   <p>123</p>
   <script>
   // 1. 获取元素 让div里面的文字发生变化
   var btn = document.querySelector('button');
   var div = document.querySelector('div');
   // 2. 注册事件 3. 添加事件处理程序
   btn.onclick = function () {
      div.innerHTML = getDate();
   }
   function getDate() {
      var date = new Date();
      var year = date.getFullYear();
      var month = date.getMonth() + 1;
      var dates = date.getDate();
      var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']/ 通过组索引号返回
      var day = date.getDay();
      return '今天是' + year + '年' + month + '月' + dates + '日   ' + arr[day];
   }
   // 元素可以不用添加事件
   var p = document.querySelector('p');
   p.innerHTML = getDate();
   <script>
   ```
### 1.2 常用元素的属性操作
   1. innerText、innerHTML 改变元素内容；
   2. src、href;
   3. id、alt、title；
   ```
   <button id="ldh">刘德华</button>
   <button id="zxy">张学友</button> <br>
   <img src="images/ldh.jpg" alt="" title="刘德华">
   <script>
      // 修改元素属性 src
      // 1. 获取元素
      var ldh = document.getElementById('ldh');
      var zxy = document.getElementById('zxy');
      var img = document.querySelector('img');
      // 2. 注册事件 3. 处理程序
      zxy.onclick = function () {
          img.src = 'images/zxy.jpg';
          img.title = '张学友';
      }
      ldh.onclick = function () {
          img.src = 'images/ldh.jpg';
          img.title = '刘德华';
      }
   </script>
   ```
### 1.3 表单元素的属性操作
   1. 利用DOM可以操作以下表单元素的属性：type,value,checked,selected,disabled;
   2. 表单里面的值 文字内容通过 value 修改;
   3. disabled用于表单禁用（不能再点击），想要按钮button禁用;
   4. this 指向的是事件函数的调用者 btn，谁调用就指向谁(true被禁用，false再启用);
   ```
   <button>按钮</button>
   <input type="text" value="输入内容">
   //1. 获取元素
   var btn = document.querySelector('button');
   var input = document.querySelector('input');
   //2. 注册事件 处理程序
   btn.onclick = function () {
      //表单里面的值 文字内容通过 value 修改
      input.value = '零零零零';
      //disabled用于表单禁用（不能再点击），想要按钮button禁用
      // btn.disabled = true;
      //this 指向的是事件函数的调用者 btn，谁调用就指向谁
      //以后用this做更方便(true被禁用，false再启用)
      this.disabled = true;
   }
   ```
### 1.4 样式属性操作
   1. 通过JS修改元素的大小、颜色、位置等样式；
   2. JS里面的样式采取驼峰命名法；
   3. element.style 行内样式操作 ：js行内样式权重比较高；（适合行内样式比较少）(案例练习13/14/15);
   4. element.style.display = 'none'; 隐藏样式 不占位置 block 显示
   ```
   <style>
      div {
         width: 200px;
         height: 200px;
         background-color: pink;
      }
   </style>
   <div></div>
   <script>
      var div = document.querySelector('div');
      div.onclick = function () {
         //div.style 里面的属性采取驼峰命名法
         this.style.backgroundColor = 'blue';
         this.style.width = '300px';
      }
   </script>
   ```
   5. element.className 类名样式操作 更改元素的压根是 （适合样式多或功能复杂）
      1. class 是保留字，所以用className来操作元素类名属性；
      2. className 会直接更改元素的类名，会覆盖原先的类名；
      3. 要保留原先的类名，使用多类名选择器（this.className = 'first change'）
   ```
   <style>
      div {
          width: 200px;
          height: 200px;
          background-color: pink;
      }
      .change {
          background-color: rgb(94, 199, 252);
          width: 300px;
          margin-top: 20px;
      }
   </style>
   <div class = "first">文本</div>
   <script>
      var text = document.querySelector('div');
      text.onclick = function () {
         //element.style 获得修改元素样式 适合样式少，功能简单
         // this.style.backgroundColor = 'blue';
         // this.style.width = '300px';
         //让当前元素的类名改为 change（相当于 div class = "change"）
         <!-- this.className = 'change'; -->
         要保留原先的类名，使用多类名选择器
         this.className = 'first change';
      }
   </script>
    ```
### 1.5 排他思想
   1. 如果有同一组元素，想要某一个元素实现某种样式，需要用到循环的排他思想算法：
      1. 所有元素全部清除样式（干掉其他人）；
      2. 给当前元素设置样式（留下自己）；
      3. 注意顺序不能颠倒，先清除，再设置；
   ```
   //点击当前按钮会变色
   <button>按钮</button>
   <button>按钮</button>
   <button>按钮</button>
   <script>
      var btns = document.getElementsByTagName('button');
      //btns 得到的是伪数组，每个元素btn[i]
      for (var i = 0; i < btns.length; i++) {
         //循环注册事件
         btns[i].onclick = function () {
            // 首先把所有元素的背景颜色去掉
            for (var i = 0; i < btns.length; i++) {
                btns[i].style.backgroundColor = '';
            }
            // 再设置当前元素的背景颜色
            this.style.backgroundColor = 'pink';
         }
      }
   </script>
    ```
### 1.6 自定义属性操作
   1. 获取属性值
      1. 内置属性值：element.属性；
      2. 自定义属性：element.getAttribute('属性'); (常用)
   2. 设置属性值；
      1. 设置内置属性值：element.属性 = '值'；
      2. 设置自定义的属性：element.setAttribute('属性', '值');
   3. 移除属性：element.removeAttribute('属性');
   ```
   <div id="demo" index='1' class="nav"></div>
    <script>
        var div = document.querySelector('div');
        //1. 获取元素的属性值
        // (1). element.属性 内置属性
        console.log(div.id);
        //(2). element.getAttribute('属性') 自定义属性
        console.log(div.getAttribute('id'));
        console.log(div.getAttribute('index'));
        // 2. 设置元素属性值
        // (1). element.属性
        div.id = 'test';
        div.className = 'navs'
        //(2). element.setAttribute('属性')
        div.setAttribute('index', 2);
        div.setAttribute('class', 'footer');// class 比较特殊 此处写class 不是className
        // 3. 移除属性removeAttribute('属性')
        div.removeAttribute('index');
    </script>
   ```   
### 1.7 H5自定义属性
   1. 自定义属性目的：为了保存并使用数据，有些数据可以保存到页面中而不用保存得到数据库中；
   2. 新增H5自定义属性（不考虑兼容性）：
      1. H5规定自定义属性 data- 开头作为属性名并且赋值：<div data-index="1"></div>；
      2. 设置自定义属性：element.setAttribute('data-time', 20)；
      3. 获得自定义属性值：element.getAttirbute('data-index');
   3. H5新增获取属性值：只能获取 data- 开头的
      1. dataset是一个集合，里面存放了所有以data开头的自定义属性（ie11以上才支持）
      2. element.dataset.index;
      3. element.dataset['index'];
   4. 如果自定义属性有多个-链接的单词，要采取 驼峰命名法：<div data-list-name ="andy"></div>
      1. element.dataset.listName;
      2. element.dataset['listName']；
## 2. 节点操作
   1. 获取元素有两种方式；
      1. 利用DOM提供的方法：逻辑性不清 但繁琐；
      2. 利用节点层级关系：逻辑性强，但兼容性差，操作简单；
### 2.1 节点概述（实际开发中，节点操作主要操作元素节点！！标签就是元素）
   1. 网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示；HTML DOM树中所有的节点均可通过JS进行访问，所有的HTML元素（节点）均可被修改，也可以创建或删除；
   2. 一般下， 节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性；
      1. 元素节点 nodeType 为 1；
      2. 属性节点 nodeType 为 2；
      3. 文本节点 nodeType 为 3（文本节点包含文字、空格、换行等）；
### 2.2 节点层级（利用DOM数把节点划分为不同的层级关系，常见的是父子兄层级关系）
   1. 父级节点：node.parentNode 得到的是离元素最近的父级节点，（不管父级有没有定位）找不到则返回为null；
   2. 子节点：
       1. 节点的子节点的集合：parentNode.childNodes（标准）
          1. 返回包含节点的子节点的集合（包括元素节点、文本节点），为即时更新的集合；
          2. 要获取里面的元素节点，则需专门处理（循环），所以不提倡使用childNodes；
       2. 获取元素节点：parentNode.children（推荐 非标准，实际开发常用的）
          1. 返回所有的子元素节点（伪数组），其余节点不返回；
       3. parentNode.firstChild 返回第一个子节点，找不到返回null；（包含所有的节点）
       4. parentNode.lastChild 返回最后一个子节点，找不到返回null；（包含所有节点）
       5. parentNode.firstElementChild 返回第一个子元素节点，找不到返回null；（推荐 ie9以上才支持）
       6. parentNode.lastElementChild 返回最后一个子元素节点，找不到返回null；（推荐 ie9以上才支持）
       7. 实际开发写法：
           1. parentNode.children[0] 返回第一个子元素节点；
           2. parentNode.children[parentNode.length - 1] 返回最后一个子元素节点；
   3. 兄弟节点：
       1. node.nextSibling 返回当前元素的下一个兄弟节点，找不到返回null（包含所有节点 元素或文本等）
       2. node.previousSibling 返回当前元素的上一个兄弟节点，找不到返回null（包含所有节点 元素或文本等）
       3. node.nextElementSibling 返回当前元素的下一个兄弟元素节点；（推荐 ie9以上才支持 ）
       4. node.previousElementSibling 返回当前元素的下一个兄弟元素节点（推荐 ie9以上才支持）
       5. 需要自己封装函数
### 2.3 创建节点（添加新元素需要创建完添加元素才会有）
   1. document.createElement('tagName') 动态创建元素节点：是根据需求动态生成的；
### 2.4 添加节点
   1. 添加节点：node.appendChild(child) 添加到指定父节点的子节点列表末尾 类似css里面after伪元素（常用）
   2. 插入节点：node.insertBefore(child, 指定元素)
   3. 替换节点：node.replaceChild()，使用新节点替换掉一个节点；
   ```
   <ul>
        <li>123</li>
    </ul>
    <script>
        // 1. 创建元素节点
        var li = document.createElement('li');
        // 2. 添加节点 node.appendChild(child) node 父级 child 子级 在后面追加元素 类似数组的push
        var ul = document.querySelector('ul');
        ul.appendChild(li);
        // 3. 添加节点 node.insertBefore(child, 指定元素)
        var lili = document.createElement('li');
        ul.insertBefore(lili, ul.children[0]);
    </script>
   ```
### 2.5 删除节点
   1. node.removeChild(child)  node 父级 从DOM中删除父节点的一个子节点，返回删除的节点。
   ```
   <button>按钮</button>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ul>
    <script>
        var ul = document.querySelector('ul');
        var btn = document.querySelector('button');
        // 2. 删除元素 
        // ul.removeChild(ul.children[0]);
        // 3. 点击按钮，依次删除里面的孩子
        btn.onclick = function () {
            // 判断ul孩子里面的长度为0时 按钮禁用
            if (ul.children.length == 0) {
                this.disabled = true;
            } else {
                ul.removeChild(ul.children[0]);
            }
        }
   </script>
   ```
### 2.6 复制节点（克隆节点）
   1. node.cloneNode() 返回调用该方法的节点的一个副本 也称 拷贝节点；
   2. () 括号里面为空 或者是false，是浅拷贝 只复制标签 不复制里面的内容；
   3. (true) 括号里面为true，是深拷贝 复制标签并且复制里面的内容；
   ```
   <ul>
        <li>1</li>
        <li>2</li>
    </ul>
    <script>
        var ul = document.querySelector('ul');
        //拷贝节点
        // var lili = ul.children[0].cloneNode();
        var lili = ul.children[0].cloneNode(true);

        // 添加节点
        ul.appendChild(lili);
    </script>
   ```
### 2.7 三种动态创建元素区别
   1. document.write():是直接将内容写入页面的内容流，正常写入没问题，但是文档流执行完毕后做了事件，它则会导致页面全部重绘；（不推荐）
   2. element.innerHTML:将内容写入某个DOM节点，不会导致页面重绘；创建多个元素效率更高（采取数组形式拼接，不要拼接字符串），结构稍复杂；
   3. createElement()：创建多个元素效率稍低一点点，但是结构更清晰；
   4. 不同浏览器下，innerHTML 效率都要比 createElement 高；（面试题！！！）
