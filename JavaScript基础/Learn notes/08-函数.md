## 1. 函数的概念
1. 函数就是封装了一段可以被重复执行调用的代码块；
2. 目的：让大量代码重复使用； 
3. 声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。
4. 函数加()就可以执行调用，表达式()：表达式的值类型是函数；（看是否有括号）
5. 所有函数都是new Function产生的（所有函数都是Function函数的实例对象，包括它本身）；
## 2. 函数的使用
### 2.1 声明函数
   1. function 是声明函数的关键字,必须小写；
   2. 函数是为了实现某个功能（做某件事）才定义的，通常将函数名命名为动词，比如 getSum ；
   ```
   //语法
   function 函数名() {
       //函数体
   }
   ```
### 2.2 调用函数
   1. 通过调用函数名来执行函数体代码；
   2. 函数不调用，自己不执行。
   ```
   //函数名();
   function sayHi() {
       console.log('hi');
   }
   sayHi();//调用函数千万不要忘记加小括号()
   ```
### 2.3 函数的封装
   1. 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口；
   2. 简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包）；
## 3. 函数的参数
### 3.1 形参和实参
1. 可以利用函数的参数实现函数重复不同的代码；
2. 作用：在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。

    1. 形参：在声明函数的小括号里面（形式上的参数）当时并不知道是什么，可以看作是不用声明的变量；
    2. 实参：在函数调用的小括号里面（实际的参数）实参是传递给形参的；
    3. 函数的参数可以有，也可以没有，个数不限。
    4. 定义任意多的参数，用逗号分隔
   ```
   // 带参数的函数声明
    function 函数名(形参1, 形参2...) { // 可以定义任意多的参数，用逗号分隔
        // 函数体
    }
    // 带参数的函数调用
    函数名(实参1, 实参2...); 
    ```
3. 执行过程
   ```
   function cook(aru) {//形参是接收实参的 aru = '你好' 形参类似于一个变量
       console.log(aru);
   }
   cook('你好');
   cook('再见');
   ```
### 3.2 函数形参实参个数匹配
   1. 形参和实参个数相等，正常输出结果；
   2. 实参个数多于形参，只取到形参的个数；
   3. 实参个数少于形参，多的形参定义为undefined，结果为NaN；
   在JavaScript中，形参的默认值是undefined。
   ```
   function getSum(num1, num2) { // 可以定义任意多的参数，用逗号分隔
      console.log(num1 + num2);
   }
   //1.形参和实参个数相等，正常输出结果
   getSum(1, 2); 
   //2. 实参个数多于形参，只取到形参的个数
   getSum(1, 2, 3); 
   //3. 实参个数少于形参，多的形参定义为undefined，最终结果为NaN
   //形参可以看作不用申明的变量 num2 是一个变量但是没有接收值，结果就是undefined
   getSum(1); 
   //建议实参和形参的个数相匹配
   ```
## 4. 函数的返回值
### 4.1 return 语句
   1. 函数只是实现某种功能，不要在内部输出结果；
   2. 最终结果要返回给函数的调用者 函数名()，通过return 实现；
   3. 只要函数遇到 return 就把后面的结果 返回给函数的调用者 函数名() = return后面的结果；
   4. 代码验证：
   ```
   function gatResult() {
      return 666;
   }
   getReult();//getResult() = 666
   conole.log(getResult());//666

   //以上输出写法不正确 完善后
   function cook(aru) {
       return(aru);
   }
   console.log(cook('你好'));

   // 求任意两个数的和
   function getSum(num1, num2) {
      return num1 + num2;
   }
   console.log(getSum(1, 2));
   ```
### 4.2 return 终止函数
   1. return后面的代码不会被执行，所以return应该在函数最后面；
   ```
   function getSum(num1, num2) {
      return num1 + num2;
      alert('我不会被执行！');// return后面的代码不会被执行
   }
   console.log(getSum(1, 2));
   ```
### 4.3 return 的返回值
   1. return只能返回一个值；
   2. 如果用逗号隔开多个值，返回结果是最后一个值
   3. 输出多个值的方法：
   ```
   //求任意两个数的 加减乘除 结果
   function getResult(num1, num2) {
      return [num1 + num2, num1 - num2, num1 * num2, num1 / num2];
   }
   var re = getResult(1, 2);//返回的是一个数组
   console.log(re);
   ```
### 4.4 函数没有 return 返回 undefined
   1. 如果有return 则返回 return 后面的值；
   2. 如果没有return 则返回 undefined ；
### 4.5 break ,continue ,return 的区别
   1. break ：结束当前的循环体（如 for、while）
   2. continue ：跳出本次循环，继续执行下次循环（如 for、while）；
   3. return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码。
### 4.6 通过榨汁机看透函数
他们俩的功能都是实现某种功能
榨汁机：
   1. 输入原料；
   2. 内部处理；
   3. 输出果汁。
函数：
   1. 输入参数；
   2. 内部处理；
   3. 返回结果。
## 5. arguments 的使用
   1. arguments 实际上它是当前函数的一个内置对象，所有函数都内置了一个 arguments 对象
   2. arguments 对象中存储了传递的所有实参。
### 5.1 arguments展示形式是一个伪数组
   1. 并不是真正意义上的数组；
   2. 具有数组的length属性；
   3. 按照索引的方式进行存储；
   4. 没有真正数组的一些方法 pop() push() 等等。
   ```
   function fn() {
      console.log(arguments);// 里面存储了所有传递过来的实参
      console.log(arguments.length);// 3
      console.log(arguments[2]);// 3
      for (var i = 0; i < arguments.length; i++) {
         console.log(arguments[i]);
      }
   }
   fn(1, 2, 3);
   fn(1, 2, 3, 4, 5);
   ```
## 6. 函数可以调用另外一个函数
1. 因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况。
```
//结果为 111/222/fn2/fn1
function fn1() {
  console.log(111);
  fn2();
  console.log('fn1');
}
function fn2() {
  console.log(222);
  console.log('fn2');
}
fn1();
```
## 7. 函数的两种声明方式
### 7.1 利用函数关键字自定义函数（命名函数）
   1. 因为有名字，所以也被称为命名函数；
   2. 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面。
   ```
   //fn();// 调用函数代码也可以放在声明函数前面
   function fn() {

   }
   fn();
   ```
### 7.2 函数表达式（匿名函数）
   1. fun 是变量名，不是函数名
   2. 函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值 而函数表达式里面存的函数；
   3. 函数调用的代码必须写到函数体后面；
   4. 所谓函数表达式就是创建一个匿名函数，然后将匿名函数对象赋值给一个变量；（赋值语句）
   ```
   //var 变量名 = function() {};
   var fun = function() {
      console.log('我是函数表达式');
   };// 赋值语句要写分号
   fun();
   ```
### 7.3 创建一个函数对象（实际开发不用这种方式）
   1. 使用typeof检查一个函数对象时，会返回function；
   2. 语法：
   ```
   var Fun = new Function() // fun是Function得实例
   ```
## 8. 函数的方法 call() 和 apply()
1. 这两个方法都是函数对象的方法，需要通过函数对象来调用；
2. 可以让一个函数成为指定任意对象的方法进行调用；（调用并修改函数运行时this的指向）
3. 当对函数调用call()和 apply()都会调用函数执行；
4. 在调用call() 和 apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this；
5. call() 和 apply()区别：(面试)
   1. call() 方法可以将实参在对象之后依次传递:fun.call(obj, 1, 2);
   2. apply() 方法需要将实参封装到一个数组中统一传递:fun.apply(obj, [1, 2])；
## 9. 原型prototype
1. 我们所创建的每一个函数，解析器都会像函数中添加一个属性prototype；
   1. 这个属性对应着一个对象，这个对象就是所谓的原型对象；
   2. 如果函数作为普通函数调用，prototype没有任何作用；
2. 当函数以构造函数的形式调用时：
   1. 它所创建的对象中会都有一个隐含的属性，指向该构造函数的原型对象；
   2. 可以通过__proto__来访问该属性(不能轻易访问)；
3. 原型对象相当于一个公告的区域，所有同一个类的实例都可以访问到这个原型对象；
4. 可以将对象中共有的内容，统一设置到原型对象中；
5. 当我们访问对象的一个属性或方法时：
   1. 会先在对象自身中寻找，找到则直接使用；
   2. 没有则去原型对象中寻找，如果找到则直接使用；
   3. 原型对象也是对象，它也有原型，如果没有则去原型的原型中找，直到找到Object对象的原型；
   4. Object对象的原型没有原型，如果在Object依然找不到，则返回undefined;
6. 以后创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中；
   1. 好处：不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法；
7. 可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性；
```
   function MyClass() {

   }
   // 向MyClass原型对象中添加属性a
   MyClass.prototype.a = 3;
   // 向MyClass原型对象中添加一个方法
   MyClass.prototype.sayHello = function () {
       alert('hello');
   }
   var mc1 = new MyClass(); 
   var mc2 = new MyClass();
   // console.log(MyClass.prototype);// Object
   //console.log(mc1.__prototype__);// Object 跟上一行指向是同一个对象
   // 向mc中添加a属性
   mc.a = '1111';
   console.log(mac.a);// 1111
   mac.sayHello();// hello
```






