## 1. 注册事件（绑定事件）
1. 概述：给元素添加事件；
2. 注册事件有两种方式：
   1. 传统方式；（其次）
   2. 方法监听注册方式；（W3C标准 推荐方式）
3. 传统方式：利用on开头的onclick；
   1. 特点：注册事件的唯一性；
   2. 同一个元素同一个时间只能设置一个处理函数，最后注册二处理含食宿将会覆盖前面注册的处理函数；
4. 方法监听注册方式:addEventListener() 是一个方法；
   1. 特点：同一个元素同一个事件可以注册多个监听器（监听处理函数）；
   2. 按照注册顺序依次执行；
   3. ie9之前不支持，可使用attachEvent()代替（移动端推荐）
### 1.1 addEventListener() 事件监听方式（首选推荐）
   1. 语法：eventTarget.addEventListener(type, listener[, useCapture])
   2. 方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发制定的事件时，就会执行事件处理函数；
   3. 该方法接收三个参数：
      1. type:事件类型字符串(要加'')，比如click、mouseover，注意这里不要带on;
      2. listener:事件处理函数，事件发生时，会调用该监听函数；
      3. useCapture:可选参数，是一个布尔值，默认false；
### 1.2 attachEvent 事件监听方式(了解 ie9之前 )
   1. eventTarget.attachEvent(eventNameWithOn, callback)
   2. eventNameWithOn:事件类型字符串，比如onclick、onmouseover，这里要带上on;
   3. callback：事件处理函数，当目标触发事件时回调函数被调用；
## 2. 删除事件（解绑事件）
### 2.1 删除事件的方式
   1. 传统注册方式：eventTarget.onclick = null;
   2. 方法监听注册方式：eventTarget.removeEventListener(type, listener[, useCapture]);
```
    <button>1</button>
    <button>2</button>
    <script>
        var btns = document.querySelectorAll('button');
        // 1. 传统方式
        btns[0].onclick = function () {
            alert(11);
            //传统方式删除事件
            btns[0].onclick = null;
        }
        // 2.事件监听注册：eventTarget.addEventListener(type, listener)
        // (1)addEventListener 里面的事件类型是字符串 要加引号'' 而且不带on
        // (2) 同一个元素，同一个事件可以添加多个监听器（事件处理程序）
        // btns[1].addEventListener('click', function () {
        //     alert(22);
        // })
        // btns[1].addEventListener('click', function () {
        //     alert(33);
        // })
        //2.事件监听方式
        btns[1].addEventListener('click', fn)// 里面的 fn 不需要调用，不加小括号
        //删除事件
        function fn() {
            alert(22);
            btns[1].removeEventListener('click', fn);
        }
        // 3. eventTarget.attachEvent(eventNameWithOn, callback)
        //注册事件
        btns[2].attachEvent('onclick', fn1);
        function fn1() {
            alert(44);
            btns[2].detachEvent('onclick', fn1);
        }
    </script>
   ```
## 3. DOM事件流
1. 事件流描述的是从页面中接收事件的顺序；
2. 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流；
3. DOM事件流分三个阶段：
   1. 捕获阶段：document-html-body-father-son
      1. 从DOM最顶层节点逐级向下（从大往小）传播到最具体元素接收的过程；
      2. 如果addEventListener第三个参数是true， 则处于捕获阶段；
   ```
   <div class="father">
        <div class="son">son</div>
    </div>
   var son = document.querySelector('.son');
        son.addEventListener('click', function () {
            alert('son');
        }, true);
        var father = document.querySelector('.father');
        father.addEventListener('click', function () {
            alert('father');
        }, true);
   ```
   2. 当前目标阶段：到了目标阶段；
   3. 冒泡阶段：son-father-body-html-document; 
      1. 开始由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程（从里往外）；
      2. 如果addEventListener第三个参数是为空或者false 处于冒泡阶段；
   ```
   var son = document.querySelector('.son');
        son.addEventListener('click', function () {
            alert('son');
        }, false);
        var father = document.querySelector('.father');
        father.addEventListener('click', function () {
            alert('father');
        }, false);
   ```
4. 注意点：
   1. 实际开发中很少使用事件捕获，更关注事件冒泡；
   2. 有些事件是没有冒泡的，比如onblur/onfocus/onmouseenter/onmouseleave；
   3. 事件冒泡有时候会带来麻烦，有时候可以帮助很巧妙的做某些事情；
   4. JS代码中只能执行捕获或者冒泡其中一个阶段；
   5. onclick和attachEvent(ie)只能得到冒泡阶段；
## 4. 事件对象
1. event就是一个事件对象 写在侦听函数的小括号里面，当形参看；
2. 事件对象有了事件才会存在，是系统给我们自动创建的，不需要我们传递参数；
3. 事件对象是 事件相关的一系列信息数据的集合，有很多属性和方法，代表事件的状态，比如鼠标的位置，键盘按哪个键；
4. 事件对象可以自己命名，比如event、evt、e；
5. 兼容性问题，ie678 需要通过window.event 兼容性的写法；
```
   <div>123</div>
   <script>
      var div = document.querySelector('div');
      //传统方式
      div.onclick = function (e) {
         console.log(e);
      }
      //事件侦听方式
      div.addEventListener('click', function (e) {
         console.log(e);
      })
   </script>
```
### 4.1 事件对象的常见属性和方法
   1. e.target：返回触发事件的对象（点击谁就返回谁），this 返回的是绑定事件的对象；（currentTarget跟this相似属性 了解）
   2. e.type：返回事件的类型，比如click,mouseover，不带on；
   3. e.preventDefault()：阻止默认行为（事件），让链接不跳转、按钮不提交、屏幕滚动等； 
## 5. 阻止事件冒泡
### 5.1 阻止事件冒泡的两种方式
   1. 标准写法：利用事件对象里面的e.stopPropagation()方法；
   2. 非标准写法：IE678 利用事件对象 cancelBubble 属性
### 6.事件委托（代理、委派）
   1. 事件委托的原理：不要给每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点；（面试！！）
   2. 作用：只操作了一次DOM，提高了程序的性能；
   ```
   <ul>
        <li>123</li>
        <li>134</li>
        <li>145</li>
   </ul>
   <script>
      // 事件委托原理：给父节点添加侦听器，利用事件冒泡影响每一个子节点
      var ul = document.querySelector('ul');
      //事件侦听方式
      ul.addEventListener('click', function (e) {
         e.target.style.backgroundColor = 'pink';
      })
   </script>
   ```
## 7. 常用的鼠标事件
### 7.1 常用的鼠标事件
   1. onclick：鼠标点击左键；
   2. onmouseover：鼠标经过；
   3. onmouseout:鼠标离开；
   4. onfocus:获得鼠标焦点；（案例在练习15）
   5. onblur:失去鼠标焦点
   6. onmousemove:鼠标移动；
   7. onmouseup:鼠标弹起；
   8. onmousedown:鼠标按下；
1. 禁止鼠标右键菜单：contextmenu控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单；
   ```
   document.addEventListener('contextmenu', function(e){
      e.preventDefault();
   })
   ```
2. 禁止鼠标选中（selectstart 开始选中）
   ```
   document.addEventListener('selectstart', function(e){
      e.preventDefault();
   })
   ```
3. mouseenter 和 mouseover 的鼠标经过事件区别：
   1. mouseover:鼠标经过自身盒子触发，经过子盒子也会触发（冒泡）；
   2. mouseenter：只会经过自身盒子触发，不会冒泡；
   3. mouseenter鼠标经过搭配 鼠标离开 mouseleave （也不冒泡）；
### 7.2 鼠标事件对象（mouseEvent）
   1. e.clientX：返回鼠标相对于浏览器窗口可视区的X坐标；
   2. e.clientY：返回鼠标相对于浏览器窗口可视区的Y坐标；
   3. e.pageX：返回鼠标相对于文档页面的X坐标；（常用 IE9+）
   4. e.pageY：返回鼠标相对于文档页面的Y坐标；（常用 IE9+）
   5. e.screenX：返回鼠标在电脑屏幕的X坐标；
   6. e.screenY：返回鼠标在电脑屏幕的Y坐标；
## 8. 常用的键盘事件
### 8.1 常用键盘事件
   1. onkeyup:某个键盘按键被松开时触发；
   2. onkeydown:键盘按键被按下时触发；
   3. onkeypress:键盘按键被按下时触发； 但不识别功能键，比如 ctrl/shift箭头等;
   4. 注意点：
      1. 如果使用addEventListener 不需要加 on ；
      2. 三个事件的执行顺序：keydown-keypress-keyup；
      3. keydown 和 keypress在文本框的特点：两个事件触发的时候，文字还没有落入文本框中；
      4. keyup事件触发的时候，文字已经落入文本框里面了；
### 8.2 键盘事件对象（keyboardEvent）
1. 键盘事件对象属性
   1. keyCode：返回该键的ASCII值；
      1. keyup/keydown 事件不区分字母大小写 a 和A得到的都是65；
      2. keypress 事件区分字母大小写 a 是97 A 是65；
      3. 可以利用keyCode返回该键的ASCII值来判断用户到底按下了哪个键;
   